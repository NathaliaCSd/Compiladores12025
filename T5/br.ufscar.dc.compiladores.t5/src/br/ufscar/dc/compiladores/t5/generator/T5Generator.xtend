/*
 * generated by Xtext 2.39.0
 * Corrigido para a gramática T5 - V2
 */
package br.ufscar.dc.compiladores.t5.generator

import br.ufscar.dc.compiladores.t5.t5.ComandoAtribuicao
import br.ufscar.dc.compiladores.t5.t5.ComandoEnquanto
import br.ufscar.dc.compiladores.t5.t5.ComandoEscreva
import br.ufscar.dc.compiladores.t5.t5.ComandoFaca
import br.ufscar.dc.compiladores.t5.t5.ComandoLeia
import br.ufscar.dc.compiladores.t5.t5.ComandoSe
import br.ufscar.dc.compiladores.t5.t5.Corpo
import br.ufscar.dc.compiladores.t5.t5.Declaracao
import br.ufscar.dc.compiladores.t5.t5.DeclaracaoLocal
import br.ufscar.dc.compiladores.t5.t5.Expressao
import br.ufscar.dc.compiladores.t5.t5.ExpressaoAritmetica
import br.ufscar.dc.compiladores.t5.t5.ExpressaoRelacional
import br.ufscar.dc.compiladores.t5.t5.FatorAritmetico
import br.ufscar.dc.compiladores.t5.t5.Programa
import br.ufscar.dc.compiladores.t5.t5.TermoAritmetico
import br.ufscar.dc.compiladores.t5.t5.TermoLogico
import br.ufscar.dc.compiladores.t5.t5.Tipo
import br.ufscar.dc.compiladores.t5.t5.Variavel
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

class T5Generator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for (p : resource.allContents.toIterable.filter(Programa)) {
			fsa.generateFile("gen/Programa.java", compilePrograma(p))
		}
	}

	def compilePrograma(Programa p) '''
		package gen;
		
		import java.util.Scanner;

		public class Programa {
			
			static Scanner sc = new Scanner(System.in);

			// Declarações de variáveis globais
			«FOR d : p.declaracoes»
				«compileDeclaracao(d)»
			«ENDFOR»

			public static void main(String[] args) {
				«compileCorpo(p.corpo)»
			}
		}
	'''
	
	def dispatch compileDeclaracao(DeclaracaoLocal d) '''
		«IF d.variaveis.size > 0»
			«FOR v : d.variaveis»
				static «getTipoJava(v.tipoVar)» «v.id.ID»;
			«ENDFOR»
		«ENDIF»
		«// TODO: Adicionar lógica para constantes e tipos, se necessário.»
	'''

	def getTipoJava(Tipo t) {
		val tipoBase = t.tipoExt?.basic
		if (tipoBase !== null) {
			switch(tipoBase) {
				case 'inteiro': 'int'
				case 'real': 'double'
				case 'literal': 'String'
				case 'logico': 'boolean'
				default: 'Object'
			}
		} else {
			// TODO: Adicionar lógica para registros e tipos definidos pelo usuário
			'Object'
		}
	}
	
	def getTipoLeitura(Variavel v) {
		val tipoBase = v.tipoVar.tipoExt?.basic
		if (tipoBase !== null) {
			switch(tipoBase) {
				case 'inteiro': 'sc.nextInt()'
				case 'real': 'sc.nextDouble()'
				case 'literal': 'sc.next()'
				case 'logico': 'sc.nextBoolean()'
				default: 'sc.next()'
			}
		} else {
			'sc.next()'
		}
	}

	def compileCorpo(Corpo c) '''
		«// TODO: Adicionar lógica para declarações locais dentro de funções/procedimentos»
		«FOR cmd : c.comandos»
			«compileComando(cmd)»
		«ENDFOR»
	'''

	// --- Compilação de Comandos ---
	def dispatch compileComando(ComandoAtribuicao c) '''
		«c.target.name» = «compileExpressao(c.valor)»;
	'''

	def dispatch compileComando(ComandoLeia c) '''
		«FOR alvo : c.alvo»
			«alvo.name» = «getTipoLeitura(alvo as Variavel)»;
		«ENDFOR»
	'''

	def dispatch compileComando(ComandoEscreva c) '''
		«FOR exp : c.exp»
			System.out.println(«compileExpressao(exp)»);
		«ENDFOR»
	'''

	def dispatch compileComando(ComandoSe c) '''
		if(«compileExpressao(c.cond)») {
			«FOR cmd : c.comandos»
				«compileComando(cmd)»
			«ENDFOR»
		}
		«IF c.comandosElse.size > 0»
		else {
			«FOR cmd : c.comandosElse»
				«compileComando(cmd)»
			«ENDFOR»
		}
		«ENDIF»
	'''
	
	def dispatch compileComando(ComandoEnquanto c) '''
		while(«compileExpressao(c.cond)») {
			«FOR cmd : c.comandos»
				«compileComando(cmd)»
			«ENDFOR»
		}
	'''
	
	def dispatch compileComando(ComandoFaca c) '''
		do {
			«FOR cmd : c.comandos»
				«compileComando(cmd)»
			«ENDFOR»
		} while(«compileExpressao(c.cond)»);
	'''
	
	// --- Compilação de Expressões ---
	def compileExpressao(Expressao e) '''«compileTermoLogico(e.logicos.get(0))»«FOR i : 1 ..< e.logicos.size» «compileOpBool(e.op.get(i-1))» «compileTermoLogico(e.logicos.get(i))»«ENDFOR»'''

	def compileTermoLogico(TermoLogico tl) '''«IF tl.isNao»!«ENDIF»(«compileExpressaoRelacional(tl.rel)»)'''

	def compileExpressaoRelacional(ExpressaoRelacional er) {
		if(er.right !== null) {
			return '''«compileExpressaoAritmetica(er.left)» «compileOpRel(er.op)» «compileExpressaoAritmetica(er.right)»'''
		}
		// Ajustado para tratar casos como 'se (variavel_logica) entao ...'
		return '''«compileExpressaoAritmetica(er.left)»'''
	}
	
	def compileExpressaoAritmetica(ExpressaoAritmetica e) '''«compileTermoAritmetico(e.termos.head)»«FOR ot : e.outros» «ot.op» «compileTermoAritmetico(ot.termo)»«ENDFOR»'''

	def compileTermoAritmetico(TermoAritmetico t) '''«compileFatorAritmetico(t.fatores.head)»«FOR of : t.outros» «of.op» «compileFatorAritmetico(of.fator)»«ENDFOR»'''
	
	def compileFatorAritmetico(FatorAritmetico f) {
		if(f.ref !== null) return f.ref.name
		if(f.numero !== null) return f.numero.toString
		if(f.real !== null) return f.real.toString
		if(f.exp !== null) return '(' + compileExpressaoAritmetica(f.exp) + ')'
		if(f.STRING !== null) return f.STRING
		return '' // Caso não seja nenhum dos anteriores
	}

	def compileOpBool(String op) {
		switch(op) {
			case 'e': '&&'
			case 'ou': '||'
			default: ''
		}
	}
	
	def compileOpRel(String op) {
		switch(op) {
			case '=': '=='
			case '<>': '!='
			default: op
		}
	}
	
	// Adicione dispatch para outros tipos de declarações e comandos conforme necessário
	def dispatch compileDeclaracao(Declaracao d) {
		'''// Declaração não tratada: «d.eClass.name»'''
	}

	def dispatch compileComando(Object o) {
		'''// Comando não tratado: «o.eClass.name»'''
	}
}