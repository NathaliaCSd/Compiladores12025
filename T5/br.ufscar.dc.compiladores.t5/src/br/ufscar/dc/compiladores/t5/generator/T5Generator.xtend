/*
 * generated by Xtext 2.39.0
 * Corrigido para a gramática T5 - V2
 */
package br.ufscar.dc.compiladores.t5.generator

import br.ufscar.dc.compiladores.t5.t5.ComandoAtribuicao
import br.ufscar.dc.compiladores.t5.t5.ComandoEnquanto
import br.ufscar.dc.compiladores.t5.t5.ComandoEscreva
import br.ufscar.dc.compiladores.t5.t5.ComandoFaca
import br.ufscar.dc.compiladores.t5.t5.ComandoLeia
import br.ufscar.dc.compiladores.t5.t5.ComandoSe
import br.ufscar.dc.compiladores.t5.t5.Corpo
import br.ufscar.dc.compiladores.t5.t5.Declaracao
import br.ufscar.dc.compiladores.t5.t5.DeclaracaoLocal
import br.ufscar.dc.compiladores.t5.t5.Expressao
import br.ufscar.dc.compiladores.t5.t5.ExpressaoAritmetica
import br.ufscar.dc.compiladores.t5.t5.ExpressaoRelacional
import br.ufscar.dc.compiladores.t5.t5.FatorAritmetico
import br.ufscar.dc.compiladores.t5.t5.Programa
import br.ufscar.dc.compiladores.t5.t5.TermoAritmetico
import br.ufscar.dc.compiladores.t5.t5.TermoLogico
import br.ufscar.dc.compiladores.t5.t5.Tipo
import br.ufscar.dc.compiladores.t5.t5.Variavel
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import br.ufscar.dc.compiladores.t5.t5.DeclaracaoGlobal

class T5Generator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for (p : resource.allContents.toIterable.filter(Programa)) {
			fsa.generateFile("gen/Programa.java", compilePrograma(p))
		}
	}

	def compilePrograma(Programa p) '''
		package gen;
		
		import java.util.Scanner;

		public class Programa {
			
			static Scanner sc = new Scanner(System.in);

			// Declarações de variáveis globais
			«FOR d : p.declaracoes»
				«compileDeclaracao(d)»
			«ENDFOR»

			public static void main(String[] args) {
				«compileCorpo(p.corpo)»
			}
		}
	'''
	
	def dispatch compileDeclaracao(DeclaracaoLocal d) '''
    «IF d.variaveis.size > 0»
        «FOR v : d.variaveis»
            // Usa v.id.name para obter o nome do identificador da variável
            static «getTipoJava(v.tipoVar)» «v.id.name»;
        «ENDFOR»
    «ENDIF»
'''

def dispatch compileDeclaracao(DeclaracaoGlobal d) '''
     public static void «d.name»() {
     	
     }
'''


	def getTipoJava(Tipo t) {
		val tipoBase = t.tipoExt?.basic
		if (tipoBase !== null) {
			switch(tipoBase) {
				case 'inteiro': 'int'
				case 'real': 'double'
				case 'literal': 'String'
				case 'logico': 'boolean'
				default: 'Object'
			}
		} else {
			'Object'
		}
	}
	
	def getTipoLeitura(Variavel v) {
		val tipoBase = v.tipoVar.tipoExt?.basic
		if (tipoBase !== null) {
			switch(tipoBase) {
				case 'inteiro': 'sc.nextInt()'
				case 'real': 'sc.nextDouble()'
				case 'literal': 'sc.next()'
				case 'logico': 'sc.nextBoolean()'
				default: 'sc.next()'
			}
		} else {
			'sc.next()'
		}
	}

	def compileCorpo(Corpo c) '''
		«FOR Comando : c.comandos»
			«compileComando(Comando)»
	«ENDFOR»
	'''

	// --- Compilação de Comandos ---
	def dispatch compileComando(ComandoAtribuicao c) '''
    «c.target.id.name» = «compileExpressao(c.valor)»;
'''

	def dispatch compileComando(ComandoLeia c) '''
    «FOR alvo : c.alvo»
        «alvo.id.name» = «getTipoLeitura(alvo)»;
    «ENDFOR»
'''

	def dispatch compileComando(ComandoEscreva c) '''
    «FOR exp : c.exp»
        System.out.print(«compileExpressao(exp)»);
    «ENDFOR»
    System.out.println(); // Adiciona uma nova linha no final
'''

	def dispatch compileComando(ComandoSe c) '''
		if(«compileExpressao(c.cond)») {
			«FOR cmd : c.comandos»
				«compileComando(cmd)»
			«ENDFOR»
		}
		«IF c.comandosElse.size > 0»
		else {
			«FOR cmd : c.comandosElse»
				«compileComando(cmd)»
			«ENDFOR»
		}
		«ENDIF»
	'''
	
	def dispatch compileComando(ComandoEnquanto c) '''
		while(«compileExpressao(c.cond)») {
			«FOR cmd : c.comandos»
				«compileComando(cmd)»
			«ENDFOR»
		}
	'''
	
	def dispatch compileComando(ComandoFaca c) '''
		do {
			«FOR cmd : c.comandos»
				«compileComando(cmd)»
			«ENDFOR»
		} while(«compileExpressao(c.cond)»);
	'''
	
	// --- Compilação de Expressões ---
	def compileExpressao(Expressao e) '''«compileTermoLogico(e.logicos.get(0))»«FOR i : 1 ..< e.logicos.size» «compileOpBool(e.op.get(i-1))» «compileTermoLogico(e.logicos.get(i))»«ENDFOR»'''

def compileTermoLogico(TermoLogico tl) '''«IF tl.nao»!«ENDIF»(«compileExpressaoRelacional(tl.rel)»)'''
	
	def compileExpressaoRelacional(ExpressaoRelacional er) {
		if(er.right !== null) {
			return '''«compileExpressaoAritmetica(er.left)» «compileOpRel(er.op)» «compileExpressaoAritmetica(er.right)»'''
		}
		// Ajustado para tratar casos como 'se (variavel_logica) entao ...'
		return '''«compileExpressaoAritmetica(er.left)»'''
	}
	
	def compileExpressaoAritmetica(ExpressaoAritmetica e) '''«compileTermoAritmetico(e.termos.head)»«FOR ot : e.outros» «ot.op» «compileTermoAritmetico(ot.termo)»«ENDFOR»'''

	def compileTermoAritmetico(TermoAritmetico t) '''«compileFatorAritmetico(t.fatores.head)»«FOR of : t.outros» «of.op» «compileFatorAritmetico(of.fator)»«ENDFOR»'''
	
	def String compileFatorAritmetico(FatorAritmetico f) {
    // Primeiro, checa a referência a outra variável
    if (f.ref !== null) {
        return f.ref.id.name
    } 
    // Depois, checa se é um literal String
    else if (f.str !== null) {
        return '"' + f.str + '"'
    } 
    // Depois, checa se é uma expressão entre parênteses
    else if (f.exp !== null) {
        return '(' + compileExpressaoAritmetica(f.exp) + ')'
    } 
    // Depois, checa se é um número real
    else if (f.real != 0.0) {
        return String.valueOf(f.real)
    } 
    // Finalmente, checa se é um número inteiro
    else if (f.numero != 0) {
        return String.valueOf(f.numero)
    }
    
    // Se não for nada disso, retorna uma string vazia
    return ""
}

	def compileOpBool(String op) {
		switch(op) {
			case 'e': '&&'
			case 'ou': '||'
			default: ''
		}
	}
	
	def compileOpRel(String op) {
		switch(op) {
			case '=': '=='
			case '<>': '!='
			default: op
		}
	}
		
}