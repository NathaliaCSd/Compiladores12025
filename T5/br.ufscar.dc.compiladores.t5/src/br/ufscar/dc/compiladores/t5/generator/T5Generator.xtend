/*
 * generated by Xtext 2.39.0
 * Corrigido para a gramática T5 - V4
 */
package br.ufscar.dc.compiladores.t5.generator

// Import necessário para a verificação robusta de tipos primitivos (eIsSet)
import br.ufscar.dc.compiladores.t5.t5.T5Package

import br.ufscar.dc.compiladores.t5.t5.ComandoAtribuicao
import br.ufscar.dc.compiladores.t5.t5.ComandoEnquanto
import br.ufscar.dc.compiladores.t5.t5.ComandoEscreva
import br.ufscar.dc.compiladores.t5.t5.ComandoFaca
import br.ufscar.dc.compiladores.t5.t5.ComandoLeia
import br.ufscar.dc.compiladores.t5.t5.ComandoSe
import br.ufscar.dc.compiladores.t5.t5.Corpo
import br.ufscar.dc.compiladores.t5.t5.DeclaracaoGlobal
import br.ufscar.dc.compiladores.t5.t5.DeclaracaoLocal
import br.ufscar.dc.compiladores.t5.t5.Expressao
import br.ufscar.dc.compiladores.t5.t5.ExpressaoAritmetica
import br.ufscar.dc.compiladores.t5.t5.ExpressaoRelacional
import br.ufscar.dc.compiladores.t5.t5.FatorAritmetico
import br.ufscar.dc.compiladores.t5.t5.Programa
import br.ufscar.dc.compiladores.t5.t5.TermoAritmetico
import br.ufscar.dc.compiladores.t5.t5.TermoLogico
import br.ufscar.dc.compiladores.t5.t5.Tipo
import br.ufscar.dc.compiladores.t5.t5.Variavel
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

class T5Generator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for (p : resource.allContents.toIterable.filter(Programa)) {
			fsa.generateFile("gen/Programa.java", compilePrograma(p))
		}
	}

	def compilePrograma(Programa p) '''
		package gen;
		
		import java.util.Scanner;

		public class Programa {
			
			static Scanner sc = new Scanner(System.in);

			«FOR d : p.declaracoes»
				«compileDeclaracao(d)»
			«ENDFOR»

			public static void main(String[] args) {
				«compileCorpo(p.corpo)»
			}
		}
	'''
	
	def dispatch compileDeclaracao(DeclaracaoLocal d) '''
		«IF d.variaveis.size > 0»
			«FOR v : d.variaveis»
				static «getTipoJava(v.tipoVar)» «v.id.name»;
			«ENDFOR»
		«ENDIF»
	'''

	def dispatch compileDeclaracao(DeclaracaoGlobal d) '''
		public static void «d.name»() {
			«compileCorpo(d.corpo)»
		}
	'''

	def getTipoJava(Tipo t) {
		val tipoBase = t.tipoExt?.basic
		if (tipoBase !== null) {
			switch(tipoBase) {
				case 'inteiro': "int"
				case 'real': "double"
				case 'literal': "String"
				case 'logico': "boolean"
				default: "Object"
			}
		} else { "Object" }
	}
	
	def getTipoLeitura(Variavel v) {
		val tipoBase = v.tipoVar.tipoExt?.basic
		if (tipoBase !== null) {
			switch(tipoBase) {
				case 'inteiro': "sc.nextInt()"
				case 'real': "sc.nextDouble()"
				case 'literal': "sc.next()"
				case 'logico': "sc.nextBoolean()"
				default: "sc.next()"
			}
		} else { "sc.next()" }
	}

	def compileCorpo(Corpo c) '''
		«FOR local : c.locais»
			«compileDeclaracao(local)»
		«ENDFOR»
		«FOR cmd : c.comandos»
			«compileComando(cmd)»
		«ENDFOR»
	'''

	// --- Compilação de Comandos ---
	def dispatch compileComando(ComandoAtribuicao c) '''
		«c.target.id.name» = «compileExpressao(c.valor)»;
	'''

	def dispatch compileComando(ComandoLeia c) '''
		«FOR alvo : c.alvo»
			«alvo.id.name» = «getTipoLeitura(alvo as Variavel)»;
		«ENDFOR»
	'''

	def dispatch compileComando(ComandoEscreva c) '''
		«FOR exp : c.exp»
			System.out.print(«compileExpressao(exp)»);
		«ENDFOR»
		System.out.println(); 
	'''

	def dispatch compileComando(ComandoSe c) '''
		if(«compileExpressao(c.cond)») {
			«FOR cmd : c.comandos»
				«compileComando(cmd)»
			«ENDFOR»
		}
		«IF c.comandosElse.size > 0»
		else {
			«FOR cmd : c.comandosElse»
				«compileComando(cmd)»
			«ENDFOR»
		}
		«ENDIF»
	'''
	
	def dispatch compileComando(ComandoEnquanto c) '''
		while(«compileExpressao(c.cond)») {
			«FOR cmd : c.comandos»
				«compileComando(cmd)»
			«ENDFOR»
		}
	'''
	
	def dispatch compileComando(ComandoFaca c) '''
		do {
			«FOR cmd : c.comandos»
				«compileComando(cmd)»
			«ENDFOR»
		} while(«compileExpressao(c.cond)»);
	'''
	
	// --- Compilação de Expressões ---
	def compileExpressao(Expressao e) '''«compileTermoLogico(e.logicos.get(0))»«FOR i : 1 ..< e.logicos.size» «compileOpBool(e.op.get(i-1))» «compileTermoLogico(e.logicos.get(i))»«ENDFOR»'''

	def compileTermoLogico(TermoLogico tl) '''«IF tl.isNao»!«ENDIF»(«compileExpressaoRelacional(tl.rel)»)'''
	
	def compileExpressaoRelacional(ExpressaoRelacional er) {
		if(er.right !== null) {
			return '''«compileExpressaoAritmetica(er.left)» «compileOpRel(er.op)» «compileExpressaoAritmetica(er.right)»'''
		}
		return '''«compileExpressaoAritmetica(er.left)»'''
	}
	
	def compileExpressaoAritmetica(ExpressaoAritmetica e) '''«compileTermoAritmetico(e.termos.head)»«FOR ot : e.outros» «ot.op» «compileTermoAritmetico(ot.termo)»«ENDFOR»'''

	def compileTermoAritmetico(TermoAritmetico t) '''«compileFatorAritmetico(t.fatores.head)»«FOR of : t.outros» «of.op» «compileFatorAritmetico(of.fator)»«ENDFOR»'''
	
	// Adicionamos "String" como tipo de retorno para ajudar o compilador
	def String compileFatorAritmetico(FatorAritmetico f) {
		if (f.ref !== null) return f.ref.id.name
		if (f.exp !== null) return '(' + compileExpressaoAritmetica(f.exp) + ')'
		
		// Verificação robusta para tipos primitivos (int, real)
		if (f.eIsSet(T5Package.Literals.FATOR_ARITMETICO__REAL)) return f.real.toString
		if (f.eIsSet(T5Package.Literals.FATOR_ARITMETICO__NUMERO)) return f.numero.toString
		
		// Corrigido para "str" (assumindo que a gramática é str=STRING)
		if (f.str !== null) return f.str
		
		return ""
	}

	def compileOpBool(String op) {
		switch(op) { case 'e': '&&' case 'ou': '||' default: '' }
	}
	
	def compileOpRel(String op) {
		switch(op) { case '=': '==' case '<>': '!=' default: op }
	}
}